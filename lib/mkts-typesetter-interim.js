(function() {
  var $, $async, ASYNC, CACHE, CND, D, HELPERS, MKTS, OPTIONS, SEMVER, TEXLIVEPACKAGEINFO, alert, badge, debug, echo, help, info, log, njs_fs, njs_path, options_route, ref, rpr, step, suspend, urge, warn, whisper, ƒ;

  njs_path = require('path');

  njs_fs = require('fs');

  CND = require('cnd');

  rpr = CND.rpr;

  badge = 'JIZURA/MKTS-interim';

  log = CND.get_logger('plain', badge);

  info = CND.get_logger('info', badge);

  whisper = CND.get_logger('whisper', badge);

  alert = CND.get_logger('alert', badge);

  debug = CND.get_logger('debug', badge);

  warn = CND.get_logger('warn', badge);

  help = CND.get_logger('help', badge);

  urge = CND.get_logger('urge', badge);

  echo = CND.echo.bind(CND);

  suspend = require('coffeenode-suspend');

  step = suspend.step;

  D = require('pipedreams');

  $ = D.remit.bind(D);

  $async = D.remit_async.bind(D);

  ASYNC = require('async');

  ƒ = CND.format_number.bind(CND);

  HELPERS = require('./HELPERS');

  MKTS = require('./MKTS');

  TEXLIVEPACKAGEINFO = require('./TEXLIVEPACKAGEINFO');

  options_route = '../options.coffee';

  ref = require('./OPTIONS'), CACHE = ref.CACHE, OPTIONS = ref.OPTIONS;

  SEMVER = require('semver');

  this.compile_options = function() {

    /* TAINT this method should go to OPTIONS */
    var cache_locator, cache_route, has_double_slash, has_single_slash, i, len, locator, locators, options_home, options_locator, ref1, route, texinputs_routes;
    options_locator = require.resolve(njs_path.resolve(__dirname, options_route));
    options_home = njs_path.dirname(options_locator);
    this.options = OPTIONS.from_locator(options_locator);
    this.options['home'] = options_home;
    this.options['locator'] = options_locator;
    cache_route = this.options['cache']['route'];
    this.options['cache']['locator'] = cache_locator = njs_path.resolve(options_home, cache_route);
    this.options['xelatex-command'] = njs_path.resolve(options_home, this.options['xelatex-command']);
    if (!njs_fs.existsSync(cache_locator)) {
      this.options['cache']['%self'] = {};
      CACHE.save(options);
    }
    this.options['cache']['%self'] = require(cache_locator);
    if ((texinputs_routes = (ref1 = this.options['texinputs']) != null ? ref1['routes'] : void 0) != null) {
      locators = [];
      for (i = 0, len = texinputs_routes.length; i < len; i++) {
        route = texinputs_routes[i];
        has_single_slash = /\/$/.test(route);
        has_double_slash = /\/\/$/.test(route);
        locator = njs_path.resolve(options_home, route);
        if (has_double_slash) {
          locator += '//';
        } else if (has_single_slash) {
          locator += '/';
        }
        locators.push(locator);
      }

      /* TAINT duplication: tex_inputs_home, texinputs_value */

      /* TAINT path separator depends on OS */
      this.options['texinputs']['value'] = locators.join(':');
    }
    return CACHE.update(this.options);
  };

  this.compile_options();

  this.write_mkts_master = function(layout_info, handler) {
    return step((function(_this) {
      return function*(resume) {
        var content_locator, defs, filename, fonts_home, fontspec_version, home, i, len, lines, main_font_name, master_locator, name, newcommands, ref1, ref2, styles, texname, text, use_new_syntax, value, write;
        lines = [];
        write = lines.push.bind(lines);
        master_locator = layout_info['master-locator'];
        content_locator = layout_info['content-locator'];
        help("writing " + master_locator);
        write("");
        write("% " + master_locator);
        write("% do not edit this file");
        write("% generated from " + _this.options['locator']);
        write("");
        write("\\documentclass[a4paper,twoside]{book}");
        write("");
        defs = _this.options['defs'];
        write("");
        write("% DEFS");
        if (defs != null) {
          for (name in defs) {
            value = defs[name];
            write("\\def\\" + name + "{" + value + "}");
          }
        }
        newcommands = _this.options['newcommands'];
        write("");
        write("% NEWCOMMANDS");
        if (newcommands != null) {
          for (name in newcommands) {
            value = newcommands[name];
            warn("implicitly converting newcommand value for " + name);
            value = njs_path.resolve(__dirname, '..', value);
            write("\\newcommand{\\" + name + "}{%\n" + value + "%\n}");
          }
        }
        write("");
        write("% PACKAGES");
        write("\\usepackage{cxltx-style-base}");
        write("\\usepackage{cxltx-style-trm}");
        write("\\usepackage{cxltx-style-pushraise}");
        write("\\usepackage{cxltx-style-hyphenation-tolerance}");
        write("\\usepackage{cxltx-style-oddeven}");
        write("\\usepackage{cxltx-style-position-absolute}");
        write("\\usepackage{cxltx-style-pushraise}");
        write("\\usepackage{cxltx-style-smashbox}");
        write("\\usepackage{mkts2015-main}");
        write("\\usepackage{mkts2015-fonts}");
        write("\\usepackage{mkts2015-article}");
        fontspec_version = (yield TEXLIVEPACKAGEINFO.read_texlive_package_version(_this.options, 'fontspec', resume));
        use_new_syntax = SEMVER.satisfies(fontspec_version, '>=2.4.0');
        fonts_home = _this.options['fonts']['home'];
        write("");
        write("% FONTS");
        write("% assuming fontspec@" + fontspec_version);
        write("\\usepackage{fontspec}");
        ref1 = _this.options['fonts']['files'];
        for (i = 0, len = ref1.length; i < len; i++) {
          ref2 = ref1[i], texname = ref2.texname, home = ref2.home, filename = ref2.filename;
          if (home == null) {
            home = fonts_home;
          }
          if (use_new_syntax) {

            /* TAINT should properly escape values */
            write("\\newfontface{\\" + texname + "}{" + filename + "}[Path=" + home + "/]");
          } else {
            write("\\newfontface\\" + texname + "[Path=" + home + "/]{" + filename + "}");
          }
        }
        write("");
        write("");
        write("% STYLES");
        if ((styles = _this.options['styles']) != null) {
          for (name in styles) {
            value = styles[name];
            write("\\newcommand{\\" + name + "}{%\n" + value + "%\n}");
          }
        }
        main_font_name = _this.options['fonts']['main'];
        if (main_font_name == null) {
          throw new Error("need entry options/fonts/name");
        }
        write("");
        write("% CONTENT");
        write("\\begin{document}" + main_font_name);
        write("");
        write("\\input{" + content_locator + "}");
        write("");
        write("\\end{document}");
        text = lines.join('\n');
        return njs_fs.writeFile(master_locator, text, handler);
      };
    })(this));
  };

  this.MKTX = {
    DOCUMENT: {},
    COMMAND: {},
    REGION: {},
    BLOCK: {},
    INLINE: {}
  };

  this.MKTX.COMMAND.$new_page = (function(_this) {
    return function(S) {
      return $(function(event, send) {
        if (!MKTS.isa(event, '∆', 'new-page')) {
          return send(event);
        }
        return send(['tex', "\\null\\newpage{}"]);
      });
    };
  })(this);

  this.MKTX.DOCUMENT.$begin = (function(_this) {
    return function(S) {
      return $(function(event, send) {
        if (MKTS.isa(event, '<', 'document')) {
          send(_this.stamp(event));
          return send(['tex', "\n% begin of MD document\n"]);
        } else {
          return send(event);
        }
      });
    };
  })(this);

  this.MKTX.DOCUMENT.$end = (function(_this) {
    return function(S) {
      return $(function(event, send) {
        if (MKTS.isa(event, '>', 'document')) {
          send(_this.stamp(event));
          return send(['tex', "\n% end of MD document\n"]);
        } else {
          return send(event);
        }
      });
    };
  })(this);

  this.MKTX.REGION._begin_multi_column = (function(_this) {
    return function(meta) {

      /* TAINT Column count must come from layout / options / MKTS-MD command */
      return ['tex', '\\begin{multicols}{2}'];
    };
  })(this);

  this.MKTX.REGION._end_multi_column = (function(_this) {
    return function(meta) {
      return ['tex', '\\end{multicols}'];
    };
  })(this);

  this.MKTX.REGION.$multi_column = (function(_this) {
    return function(S) {
      var track;
      track = MKTS.TRACKER.new_tracker('{multi-column}');
      return $(function(event, send) {
        var meta, name, text, type, within_multi_column;
        within_multi_column = track.within('{multi-column}');
        track(event);
        if (MKTS.isa(event, ['{', '}'], 'multi-column')) {
          send(_this.stamp(event));
          type = event[0], name = event[1], text = event[2], meta = event[3];
          if (type === '{') {
            if (within_multi_column) {
              whisper("ignored " + type + name);
            } else {
              send(track(_this.MKTX.REGION._begin_multi_column()));
            }
          } else {
            if (within_multi_column) {
              send(track(_this.MKTX.REGION._end_multi_column()));
            } else {
              whisper("ignored " + type + name);
            }
          }
        } else {
          send(event);
        }
        return null;
      });
    };
  })(this);

  this.MKTX.REGION.$single_column = (function(_this) {
    return function(S) {

      /* TAINT consider to implement command `change_column_count = ( send, n )` */
      var track;
      track = MKTS.TRACKER.new_tracker('{multi-column}');
      return $(function(event, send) {
        var meta, name, text, type, within_multi_column;
        within_multi_column = track.within('{multi-column}');
        track(event);
        if (MKTS.isa(event, ['{', '}'], 'single-column')) {
          send(_this.stamp(event));
          type = event[0], name = event[1], text = event[2], meta = event[3];
          if (type === '{') {
            if (within_multi_column) {
              send(track(_this.MKTX.REGION._end_multi_column()));
            } else {
              whisper("ignored " + type + name);
            }
          } else {
            if (within_multi_column) {
              send(track(_this.MKTX.REGION._begin_multi_column()));
            } else {
              whisper("ignored " + type + name);
            }
          }
        } else {
          send(event);
        }
        return null;
      });
    };
  })(this);

  this.MKTX.REGION.$correct_p_tags_before_regions = (function(_this) {
    return function(S) {
      var last_was_begin_document, last_was_p;
      last_was_p = false;
      last_was_begin_document = false;
      return $(function(event, send) {
        var meta;
        if (MKTS.isa(event, 'tex')) {
          return send(event);
        } else if (MKTS.isa(event, '<', 'document')) {
          last_was_p = false;
          last_was_begin_document = true;
          return send(event);
        } else if (MKTS.isa(event, '.', 'p')) {
          last_was_p = true;
          last_was_begin_document = false;
          return send(event);
        } else if (MKTS.isa(event, ['{', '['])) {
          if ((!last_was_begin_document) && (!last_was_p)) {
            meta = event[event.length - 1];
            send(['.', 'p', null, MKTS._copy(meta)]);
          }
          send(event);
          last_was_p = false;
          return last_was_begin_document = false;
        } else {
          last_was_p = false;
          last_was_begin_document = false;
          return send(event);
        }
      });
    };
  })(this);

  this.MKTX.REGION.$keep_lines = (function(_this) {
    return function(S) {
      var track;
      track = MKTS.TRACKER.new_tracker('{keep-lines}');
      return $(function(event, send) {
        var meta, name, text, type, within_keep_lines;
        within_keep_lines = track.within('{keep-lines}');
        track(event);
        if (MKTS.isa(event, '.', 'text')) {
          type = event[0], name = event[1], text = event[2], meta = event[3];

          /* TAINT other replacements possible; use API */

          /* TAINT U+00A0 (nbsp) might be too wide */
          if (within_keep_lines) {
            text = text.replace(/\u0020/g, '\u00a0');
          }
          return send([type, name, text, meta]);
        } else if (MKTS.isa(event, ['{', '}'], 'keep-lines')) {
          send(_this.stamp(event));
          type = event[0], name = event[1], text = event[2], meta = event[3];
          if (type === '{') {
            track.enter('{keep-lines}');
            return send(['tex', "\\begingroup\\obeyalllines{}"]);
          } else {
            send(['tex', "\\endgroup{}"]);
            return track.leave('{keep-lines}');
          }
        } else {
          return send(event);
        }
      });
    };
  })(this);

  this.MKTX.REGION.$code = (function(_this) {
    return function(S) {

      /* TAINT code duplication with `REGION.$keep_lines` possible */
      var track;
      track = MKTS.TRACKER.new_tracker('{code}');
      return $(function(event, send) {
        var meta, name, text, type, within_code;
        within_code = track.within('{code}');
        track(event);
        if (MKTS.isa(event, '.', 'text')) {
          type = event[0], name = event[1], text = event[2], meta = event[3];
          if (within_code) {
            text = text.replace(/\u0020/g, '\u00a0');
          }
          return send([type, name, text, meta]);
        } else if (MKTS.isa(event, ['{', '}'], 'code')) {
          send(_this.stamp(event));
          type = event[0], name = event[1], text = event[2], meta = event[3];
          if (type === '{') {
            return send(['tex', "\\begingroup\\obeyalllines\\mktsStyleCode{}"]);
          } else {
            return send(['tex', "\\endgroup{}"]);
          }
        } else {
          return send(event);
        }
      });
    };
  })(this);

  this.MKTX.BLOCK.$remove_empty_p_tags = (function(_this) {
    return function(S) {
      var last_was_text;
      last_was_text = false;
      return $(function(event, send) {
        if (MKTS.isa(event, '.', 'text')) {
          last_was_text = true;
          return send(event);
        } else if (MKTS.isa(event, '.', 'p')) {
          if (last_was_text) {
            send(event);
          } else {
            whisper("ignoring empty `p` tag");
          }
          return last_was_text = false;
        } else {
          last_was_text = false;
          return send(event);
        }
      });
    };
  })(this);

  this.MKTX.BLOCK.$heading = (function(_this) {
    return function(S) {
      var restart_multicols, track;
      restart_multicols = false;
      track = MKTS.TRACKER.new_tracker('{multi-column}');
      return $(function(event, send) {
        var meta, name, text, type, within_multi_column;
        within_multi_column = track.within('{multi-column}');
        track(event);
        if (MKTS.isa(event, ['[', ']'], ['h1', 'h2', 'h3', 'h4', 'h5', 'h6'])) {
          send(_this.stamp(event));
          type = event[0], name = event[1], text = event[2], meta = event[3];
          if (type === '[') {
            if (within_multi_column && (name === 'h1' || name === 'h2')) {
              send(track(_this.MKTX.REGION._end_multi_column(meta)));
              restart_multicols = true;
            }
            send(['tex', "\n"]);
            switch (name) {
              case 'h1':
                return send(['tex', "\\chapter{"]);
              case 'h2':
                return send(['tex', "\\section{"]);
              default:
                return send(['tex', "\\subsection{"]);
            }
          } else {

            /* Placing the closing brace on a new line seems to improve line breaking */
            send(['tex', "\n"]);
            send(['tex', "}"]);
            send(['tex', "\n"]);
            if (restart_multicols) {
              send(track(_this.MKTX.REGION._begin_multi_column(meta)));
              return restart_multicols = false;
            }
          }
        } else {
          return send(event);
        }
      });
    };
  })(this);

  this.MKTX.BLOCK.$paragraph = (function(_this) {
    return function(S) {

      /* TAINT should unify the two observers */
      var track;
      track = MKTS.TRACKER.new_tracker('{code}', '{keep-lines}');
      return $(function(event, send) {
        var meta, name, text, type, within_code, within_keep_lines;
        within_code = track.within('{code}');
        within_keep_lines = track.within('{keep-lines}');
        track(event);
        if (MKTS.isa(event, '.', 'p')) {
          type = event[0], name = event[1], text = event[2], meta = event[3];
          if (within_code || within_keep_lines) {
            send(_this.stamp(event));
            return send(['text', '\n\n']);
          } else {
            send(_this.stamp(event));

            /* TAINT use command from sty */

            /* TAINT make configurable */
            return send(['tex', '\\mktsShowpar\\par\n']);
          }
        } else {
          return send(event);
        }
      });
    };
  })(this);

  this.MKTX.BLOCK.$hr = (function(_this) {
    return function(S) {
      return $(function(event, send) {
        var chr, meta, name, text, type;
        if (MKTS.isa(event, '.', 'hr')) {
          send(_this.stamp(event));
          type = event[0], name = event[1], text = event[2], meta = event[3];
          switch (chr = text[0]) {
            case '-':
              return send(['text', '\n--------------\n']);
            case '*':
              return send(['text', '\n**************\n']);
            default:
              return warn("ignored hr markup " + (rpr(text)));
          }
        } else {
          return send(event);
        }
      });
    };
  })(this);

  this.MKTX.INLINE.$code = (function(_this) {
    return function(S) {
      return $(function(event, send) {
        var meta, name, text, type;
        if (MKTS.isa(event, ['(', ')'], 'code')) {
          send(_this.stamp(event));
          type = event[0], name = event[1], text = event[2], meta = event[3];
          if (type === '(') {
            return send(['tex', '{\\mktsStyleCode{}']);
          } else {
            return send(['tex', "}"]);
          }
        } else {
          return send(event);
        }
      });
    };
  })(this);

  this.MKTX.INLINE.$latex = (function(_this) {
    return function(S) {
      var track;
      track = MKTS.TRACKER.new_tracker('(latex)');
      return $(function(event, send) {
        var meta, name, raw_text, text, type, within_latex;
        within_latex = track.within('(latex)');
        track(event);
        if (within_latex && MKTS.isa(event, '.', 'text')) {
          type = event[0], name = event[1], text = event[2], meta = event[3];
          raw_text = meta['raw'];

          /* TAINT could the added `{}` conflict with some (La)TeX commands? */
          return send(_this.stamp(['.', 'latex', raw_text, meta]));
        } else if (MKTS.isa(event, ['(', ')'], 'latex')) {
          return send(_this.stamp(event));
        } else {
          return send(event);
        }
      });
    };
  })(this);

  this.MKTX.INLINE.$translate_i_and_b = (function(_this) {
    return function(S) {
      return $(function(event, send) {
        var meta, name, new_name, text, type;
        if (MKTS.isa(event, ['(', ')'], ['i', 'b'])) {
          type = event[0], name = event[1], text = event[2], meta = event[3];
          new_name = name === 'i' ? 'em' : 'strong';
          return send([type, new_name, text, meta]);
        } else {
          return send(event);
        }
      });
    };
  })(this);

  this.MKTX.INLINE.$em_and_strong = (function(_this) {
    return function(S) {
      return $(function(event, send) {
        var meta, name, text, type;
        if (MKTS.isa(event, ['(', ')'], ['em', 'strong'])) {
          send(_this.stamp(event));
          type = event[0], name = event[1], text = event[2], meta = event[3];
          if (type === '(') {
            if (name === 'em') {
              return send(['tex', '{\\mktsStyleItalic{}']);
            } else {
              return send(['tex', '{\\mktsStyleBold{}']);
            }
          } else {
            return send(['tex', "}"]);
          }
        } else {
          return send(event);
        }
      });
    };
  })(this);

  this.$show_unhandled_tags = function(S) {
    return $((function(_this) {
      return function(event, send) {

        /* TAINT selection could be simpler, less repetitive */
        var event_tex, ref1;
        if ((ref1 = event[0]) === 'tex' || ref1 === 'text') {
          return send(event);
        } else if (MKTS.isa(event, '.', 'text')) {
          return send(event);
        } else if (!event[3]['processed']) {
          event_tex = MKTS.fix_typography_for_tex(rpr(event), _this.options);
          send(['tex', "\\mktsErrorbox{unhandled event: " + event_tex + "}"]);
          return send(event);
        } else {
          return send(event);
        }
      };
    })(this));
  };

  this.$filter_tex = function() {
    return $((function(_this) {
      return function(event, send) {
        var ref1;
        if ((ref1 = event[0]) === 'tex' || ref1 === 'text') {
          return send(event[1]);
        } else if (MKTS.isa(event, '.', ['text', 'latex'])) {
          return send(event[2]);
        } else {
          if (!event[3]['processed']) {
            return warn("unhandled event: " + (JSON.stringify(event)));
          }
        }
      };
    })(this));
  };

  this.stamp = (function(_this) {
    return function(event) {
      event[3]['processed'] = true;
      return event;
    };
  })(this);

  this.pdf_from_md = function(source_route, handler) {
    return step((function(_this) {
      return function*(resume) {
        var content_locator, input, layout_info, source_locator, state, tex_output, text;
        if (handler == null) {
          handler = function() {};
        }
        layout_info = HELPERS.new_layout_info(_this.options, source_route);
        (yield _this.write_mkts_master(layout_info, resume));
        source_locator = layout_info['source-locator'];
        content_locator = layout_info['content-locator'];
        tex_output = njs_fs.createWriteStream(content_locator);

        /* TAINT should read MD source stream */
        text = njs_fs.readFileSync(source_locator, {
          encoding: 'utf-8'
        });
        state = {
          options: _this.options,
          layout_info: layout_info
        };
        tex_output.on('close', function() {
          return HELPERS.write_pdf(layout_info, function(error) {
            if (error != null) {
              throw error;
            }
            if (handler != null) {
              return handler(null);
            }
          });
        });
        input = MKTS.create_mdreadstream(text);
        input.pipe(MKTS.$fix_typography_for_tex(_this.options)).pipe(_this.MKTX.DOCUMENT.$begin(state)).pipe(_this.MKTX.COMMAND.$new_page(state)).pipe(_this.MKTX.REGION.$correct_p_tags_before_regions(state)).pipe(_this.MKTX.REGION.$multi_column(state)).pipe(_this.MKTX.REGION.$single_column(state)).pipe(_this.MKTX.REGION.$keep_lines(state)).pipe(_this.MKTX.REGION.$code(state)).pipe(_this.MKTX.BLOCK.$remove_empty_p_tags(state)).pipe(_this.MKTX.BLOCK.$heading(state)).pipe(_this.MKTX.BLOCK.$paragraph(state)).pipe(_this.MKTX.BLOCK.$hr(state)).pipe(_this.MKTX.INLINE.$code(state)).pipe(_this.MKTX.INLINE.$latex(state)).pipe(_this.MKTX.INLINE.$translate_i_and_b(state)).pipe(_this.MKTX.INLINE.$em_and_strong(state)).pipe(_this.MKTX.DOCUMENT.$end(state)).pipe(MKTS.$show_mktsmd_events(state)).pipe(MKTS.$write_mktscript(state)).pipe(_this.$show_unhandled_tags(state)).pipe(_this.$filter_tex()).pipe(tex_output);
        return input.resume();
      };
    })(this));
  };

  if (module.parent == null) {
    this.pdf_from_md('texts/demo');
  }

}).call(this);

//# sourceMappingURL=../sourcemaps/mkts-typesetter-interim.js.map