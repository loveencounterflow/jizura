{"version":3,"sources":["compare-recent-cjkvi-ids-data.coffee"],"names":[],"mappings":"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","file":"compare-recent-cjkvi-ids-data.js","sourceRoot":"/source/","sourcesContent":["\n\n\n############################################################################################################\nnjs_path                  = require 'path'\nnjs_fs                    = require 'fs'\njoin                      = njs_path.join\n#...........................................................................................................\nCND                       = require 'cnd'\nrpr                       = CND.rpr\nbadge                     = 'HOLLERITH/copy'\nlog                       = CND.get_logger 'plain',     badge\ninfo                      = CND.get_logger 'info',      badge\nwhisper                   = CND.get_logger 'whisper',   badge\nalert                     = CND.get_logger 'alert',     badge\ndebug                     = CND.get_logger 'debug',     badge\nwarn                      = CND.get_logger 'warn',      badge\nhelp                      = CND.get_logger 'help',      badge\nurge                      = CND.get_logger 'urge',      badge\necho                      = CND.echo.bind CND\n#...........................................................................................................\nsuspend                   = require 'coffeenode-suspend'\nstep                      = suspend.step\nafter                     = suspend.after\neventually                = suspend.eventually\nimmediately               = suspend.immediately\nrepeat_immediately        = suspend.repeat_immediately\nevery                     = suspend.every\n#...........................................................................................................\nD                         = require 'pipedreams'\n$                         = D.remit.bind D\n$async                    = D.remit_async.bind D\n#...........................................................................................................\nHOLLERITH                 = require 'hollerith'\n# DEMO                      = require './demo'\nCHR                       = require 'coffeenode-chr'\nƒ                         = CND.format_number.bind CND\n\n#-----------------------------------------------------------------------------------------------------------\noptions =\n  # sample:         null\n  # sample:         [ '疈', '國', '𠵓', ]\n  # sample:         [ '𡬜', '國', '𠵓', ]\n\n# #-----------------------------------------------------------------------------------------------------------\n# @$show_progress = ( size ) ->\n#   size   ?= 1e3\n#   count   = 0\n#   return $ ( data, send ) =>\n#     count += 1\n#     echo ƒ count if count % size is 0\n#     send data\n\n#-----------------------------------------------------------------------------------------------------------\n@$show_progress = ( size ) ->\n  size         ?= 1e3\n  phrase_count  = 0\n  glyph_count   = 0\n  last_glyph    = null\n  return D.$observe ( _, has_ended ) =>\n    unless has_ended\n      phrase_count += 1\n      echo ƒ phrase_count if phrase_count % size is 0\n    else\n      help \"read #{ƒ phrase_count} records\"\n\n# #-----------------------------------------------------------------------------------------------------------\n# @$keep_small_sample = ->\n#   return $ ( key, send ) =>\n#     return send key unless options[ 'sample' ]?\n#     [ glyph, prd, obj, idx, ] = key\n#     send key if glyph in options[ 'sample' ]\n\n# #-----------------------------------------------------------------------------------------------------------\n# @$throw_out_pods = ->\n#   return $ ( key, send ) =>\n#     [ glyph, prd, obj, idx, ] = key\n#     send key unless prd is 'pod'\n\n# #-----------------------------------------------------------------------------------------------------------\n# @$cast_types = ( ds_options ) ->\n#   return $ ( [ sbj, prd, obj, idx, ], send ) =>\n#     type_description = ds_options[ 'schema' ][ prd ]\n#     unless type_description?\n#       warn \"no type description for predicate #{rpr prd}\"\n#     else\n#       switch type = type_description[ 'type' ]\n#         when 'int'\n#           obj = parseInt obj, 10\n#         when 'text'\n#           ### TAINT we have no booleans configured ###\n#           if      obj is 'true'   then obj = true\n#           else if obj is 'false'  then obj = false\n#     send if idx? then [ sbj, prd, obj, idx, ] else [ sbj, prd, obj, ]\n\n# #-----------------------------------------------------------------------------------------------------------\n# @$collect_lists = ->\n#   objs          = null\n#   sbj_prd       = null\n#   last_digest   = null\n#   context_keys  = []\n#   has_errors    = false\n#   #.........................................................................................................\n#   return $ ( key, send, end ) =>\n#     #.......................................................................................................\n#     if key?\n#       context_keys.push key; context_keys.shift() if context_keys.length > 10\n#       [ sbj, prd, obj, idx, ] = key\n#       digest                  = JSON.stringify [ sbj, prd, ]\n#       #.....................................................................................................\n#       if digest is last_digest\n#         if idx?\n#           objs[ idx ] = obj\n#         else\n#           ### A certain subject/predicate combination can only ever be repeated if an index is\n#           present in the key ###\n#           alert()\n#           alert \"erroneous repeated entry; context:\"\n#           alert context_keys\n#           has_errors = true\n#       else\n#         send [ sbj_prd..., objs, ] if objs?\n#         objs            = null\n#         last_digest     = digest\n#         if idx?\n#           objs            = []\n#           objs[ idx ]     = obj\n#           sbj_prd         = [ sbj, prd, ]\n#         else\n#           send key\n#     #.......................................................................................................\n#     if end?\n#       send [ sbj_prd..., objs, ] if objs?\n#       return send.error new Error \"there were errors; see alerts above\" if has_errors\n#       end()\n#     #.......................................................................................................\n#     return null\n\n# #-----------------------------------------------------------------------------------------------------------\n# @$compact_lists = ->\n#   return $ ( [ sbj, prd, obj, ], send ) =>\n#     ### Compactify sparse lists so all `undefined` elements are removed; warn about this ###\n#     if ( CND.type_of obj ) is 'list'\n#       new_obj = ( element for element in obj when element isnt undefined )\n#       if obj.length isnt new_obj.length\n#         warn \"phrase #{rpr [ sbj, prd, obj, ]} contained undefined elements; compactified\"\n#       obj = new_obj\n#     send [ sbj, prd, obj, ]\n\n# #-----------------------------------------------------------------------------------------------------------\n# @$add_version_to_kwic_v1 = ->\n#   ### mark up all predicates `guide/kwic/*` as `guide/kwic/v1/*` ###\n#   return $ ( [ sbj, prd, obj, ], send ) =>\n#     if prd.startsWith 'guide/kwic/'\n#       prd = prd.replace /^guide\\/kwic\\//, 'guide/kwic/v1/'\n#     send [ sbj, prd, obj, ]\n\n# #-----------------------------------------------------------------------------------------------------------\n# @_long_wrapped_lineups_from_guides = ( guides ) ->\n#   ### Extending lineups to accommodate for glyphs with 'overlong' factorials (those with more than 6\n#   factors; these were previously excluded from the gamut in `feed-db.coffee`, line 2135,\n#   `@KWIC.$compose_lineup_facets`). ###\n#   ### TAINT here be magic numbers ###\n#   lineup      = guides[ .. ]\n#   last_idx    = lineup.length - 1 + 6\n#   lineup.push    '\\u3000' while lineup.length < 19\n#   lineup.unshift '\\u3000' while lineup.length < 25\n#   R           = []\n#   for idx in [ 6 .. last_idx ]\n#     infix   = lineup[ idx ]\n#     suffix  = lineup[ idx + 1 .. idx + 6 ].join ''\n#     prefix  = lineup[ idx - 6 .. idx - 1 ].join ''\n#     R.push [ infix, suffix, prefix, ].join ','\n#   return R\n\n# #-----------------------------------------------------------------------------------------------------------\n# @$add_kwic_v2 = ->\n#   ### see `demo/show_kwic_v2_and_v3_sample` ###\n#   last_glyph            = null\n#   long_wrapped_lineups  = null\n#   return $ ( [ sbj, prd, obj, ], send ) =>\n#     #.......................................................................................................\n#     if prd is 'guide/has/uchr'\n#       last_glyph            = sbj\n#       long_wrapped_lineups  = @_long_wrapped_lineups_from_guides obj\n#     #.......................................................................................................\n#     return send [ sbj, prd, obj, ] unless prd.startsWith 'guide/kwic/v1/'\n#     #.......................................................................................................\n#     switch prd.replace /^guide\\/kwic\\/v1\\//, ''\n#       when 'lineup/wrapped/infix', 'lineup/wrapped/prefix', 'lineup/wrapped/suffix', 'lineup/wrapped/single'\n#         ### copy to target ###\n#         send [ sbj, prd, obj, ]\n#       when 'sortcode'\n#         [ glyph, _, sortcodes_v1, ] = [ sbj, prd, obj, ]\n#         sortcodes_v2                = []\n#         #...................................................................................................\n#         ### The difference between KWIC sortcodes of version 1 and version 2 lies in the re-arrangement\n#         of the factor codes and the index codes. In v1, the index codes appeared interspersed with\n#         the factor codes; in v2, the index codes come up front and the index codes come in the latter half\n#         of the sortcode strings. The effect of this rearrangement is that now that all of the indexes\n#         (which indicate the position of each factor in the lineup) are weaker than any of the factor codes,\n#         like sequences of factor codes (and, therefore, factors) will always be grouped together (whereas\n#         in v1, only like factors with like positions appeared together, and often like sequences appeared\n#         with other sequences interspersed where their indexes demanded it so). ###\n#         for sortcode_v1 in sortcodes_v1\n#           sortrow_v1 = ( x for x in sortcode_v1.split /(........,..),/ when x.length > 0 )\n#           sortrow_v1 = ( x.split ',' for x in sortrow_v1 )\n#           sortrow_v2 = []\n#           sortrow_v2.push sortcode for [ sortcode, _, ] in sortrow_v1\n#           sortrow_v2.push position for [ _, position, ] in sortrow_v1\n#           sortcodes_v2.push sortrow_v2.join ','\n#         #...................................................................................................\n#         unless glyph is last_glyph\n#           return send.error new Error \"unexpected mismatch: #{rpr glyph}, #{rpr last_glyph}\"\n#         #...................................................................................................\n#         unless long_wrapped_lineups?\n#           return send.error new Error \"missing long wrapped lineups for glyph #{rpr glyph}\"\n#         #...................................................................................................\n#         unless sortcodes_v2.length is long_wrapped_lineups.length\n#           warn 'sortcodes_v2:         ', sortcodes_v2\n#           warn 'long_wrapped_lineups: ', long_wrapped_lineups\n#           return send.error new Error \"length mismatch for glyph #{rpr glyph}\"\n#         #...................................................................................................\n#         sortcodes_v1[ idx ] += \";\" + lineup for lineup, idx in long_wrapped_lineups\n#         sortcodes_v2[ idx ] += \";\" + lineup for lineup, idx in long_wrapped_lineups\n#         send [ glyph, 'guide/kwic/v2/lineup/wrapped/single', long_wrapped_lineups, ]\n#         long_wrapped_lineups  = null\n#         #...................................................................................................\n#         send [ glyph, prd, sortcodes_v1, ]\n#         send [ glyph, 'guide/kwic/v2/sortcode', sortcodes_v2, ]\n#       else\n#         send.error new Error \"unhandled predicate #{rpr prd}\"\n\n# #-----------------------------------------------------------------------------------------------------------\n# @$add_kwic_v3 = ( factor_infos ) ->\n#   ### see `demo/show_kwic_v2_and_v3_sample` ###\n#   #.........................................................................................................\n#   return $ ( [ sbj, prd, obj, ], send ) =>\n#     send [ sbj, prd, obj, ]\n#     return unless prd is 'guide/kwic/v1/sortcode'\n#     #.......................................................................................................\n#     [ glyph, _, [ sortcode_v1, ... ], ] = [ sbj, prd, obj, ]\n#     #.......................................................................................................\n#     sortrow_v1    = ( x for x in sortcode_v1.split /(........,..),/ when x.length > 0 )\n#     weights       = ( x.split ',' for x in sortrow_v1 )\n#     weights.pop()\n#     weights       = ( sortcode for [ sortcode, _, ] in weights )\n#     weights       = ( sortcode for sortcode in weights when sortcode isnt '--------' )\n#     weights       = ( ( sortcode.replace    /~/g, '-'    ) for sortcode in weights )\n#     weights       = ( ( sortcode.replace /----/g, 'f---' ) for sortcode in weights )\n#     #.......................................................................................................\n#     factors       = ( factor_infos[ sortcode ] for sortcode in weights )\n#     factors       = ( ( if factor? then factor else '〓' ) for factor in factors )\n#     #.......................................................................................................\n#     unless weights.length is factors.length\n#       warn glyph, weights, factors, weights.length, factors.length\n#       return\n#     #.......................................................................................................\n#     permutations = KWIC.get_permutations factors, weights\n#     send [ glyph, 'guide/kwic/v3/sortcode', permutations, ]\n\n# #-----------------------------------------------------------------------------------------------------------\n# @v1_split_so_bkey = ( bkey ) ->\n#   R       = bkey.toString 'utf-8'\n#   R       = R.split '|'\n#   idx_txt = R[ 3 ]\n#   R       = [ ( R[ 1 ].split ':' )[ 1 ], ( R[ 2 ].split ':' )..., ]\n#   R.push ( parseInt idx_txt, 10 ) if idx_txt? and idx_txt.length > 0\n#   for r, idx in R\n#     continue unless CND.isa_text r\n#     continue unless 'µ' in r\n#     R[ idx ] = @v1_unescape r\n#   return R\n\n# #-----------------------------------------------------------------------------------------------------------\n# @v1_$split_so_bkey = -> $ ( bkey, send ) => send @v1_split_so_bkey bkey\n\n# #-----------------------------------------------------------------------------------------------------------\n# @v1_lte_from_gte = ( gte ) ->\n#   R = new Buffer ( last_idx = Buffer.byteLength gte ) + 1\n#   R.write gte\n#   R[ last_idx ] = 0xff\n#   return R\n\n# #-----------------------------------------------------------------------------------------------------------\n# @v1_unescape = ( text_esc ) ->\n#   matcher = /µ([0-9a-f]{2})/g\n#   return text_esc.replace matcher, ( _, cid_hex ) ->\n#     return String.fromCharCode parseInt cid_hex, 16\n\n# #-----------------------------------------------------------------------------------------------------------\n# @read_factors = ( db, handler ) ->\n#   #.........................................................................................................\n#   Z         = {}\n#   #.......................................................................................................\n#   gte         = 'os|factor/sortcode'\n#   lte         = @v1_lte_from_gte gte\n#   input       = db[ '%self' ].createKeyStream { gte, lte, }\n#   XNCHR       = require '../../jizura-datasources/lib/XNCHR'\n#   #.......................................................................................................\n#   input\n#     .pipe @v1_$split_so_bkey()\n#     .pipe D.$observe ( [ sortcode, _, factor, ] ) =>\n#       Z[ sortcode ] = XNCHR.as_uchr factor\n#     .pipe D.$on_end -> handler null, Z\n\n\n#-----------------------------------------------------------------------------------------------------------\noptions =\n  'comment-marks':              [ '#', ';', ]\n  'cjkvi-ncr-kernel-pattern':   /^(?:(U)\\+|(CDP)-)([0-9A-F]{4,5})$/\n  'cjkvi-ncr-pattern':          /&([^;]+);/g\n  'blank-line-tester':          /^\\s*$/\n  'known-ref-mismatches':\n    '鿉鿈':                     '鿉'\n\n#-----------------------------------------------------------------------------------------------------------\n@read_glyph_categories = ( db, handler ) ->\n  Z     = {}\n  count = 0\n  query = { prefix: [ 'pos', 'cp/' ], star: '*', }\n  input = HOLLERITH.create_phrasestream db, query\n  input\n    # .pipe D.$show()\n    .pipe $ ( phrase, send ) =>\n      [ _, prd, _, glyph, ] = phrase\n      if prd in [ 'cp/inner/original', 'cp/inner/mapped', 'cp/outer/original', 'cp/outer/mapped', ]\n        Z[ glyph ]  = prd\n        count      += +1\n        send glyph\n    .pipe @$show_progress 1e4\n    .pipe D.$on_end =>\n      help \"read categories for #{ƒ count} glyphs\"\n      njs_fs.writeFileSync '/tmp/glyph-categories.json', JSON.stringify Z, null, '  '\n      handler null, Z\n\n#-----------------------------------------------------------------------------------------------------------\n@$filter_comments_and_empty_lines = ->\n  return $ ( line, send ) =>\n    if ( options[ 'blank-line-tester' ].test line ) or line[ 0 ] in options[ 'comment-marks' ]\n      null # warn line\n    else\n      send line\n\n#-----------------------------------------------------------------------------------------------------------\n@chr_from_cjkvi_ncr_kernel = ( cjkvi_ncr_kernel ) ->\n  match = cjkvi_ncr_kernel.match options[ 'cjkvi-ncr-kernel-pattern' ]\n  unless match?\n    throw new Error \"unexpected CJVKI NCR kernel: #{rpr cjkvi_ncr_kernel}\"\n  else\n    csg = ( match[ 1 ] ? match[ 2 ] ).toLowerCase()\n    cid = parseInt match[ 3 ], 16\n    return CHR._as_chr csg, cid\n\n#-----------------------------------------------------------------------------------------------------------\n@$resolve_cjkvi_kernel = ->\n  return $ ( fields, send ) =>\n    return if fields.length is 0\n    [ cjkvi_ncr_kernel, glyph, cjkvi_formulas..., ] = fields\n    glyph_reference = @chr_from_cjkvi_ncr_kernel cjkvi_ncr_kernel\n    send [ glyph_reference, glyph, cjkvi_formulas..., ]\n\n#-----------------------------------------------------------------------------------------------------------\n@$normalize_cjkvi_ncrs = ->\n  pattern = options[ 'cjkvi-ncr-pattern' ]\n  return $ ( fields, send ) =>\n    for field_idx in [ 1 ... fields.length ]\n      fields[ field_idx ] = fields[ field_idx ].replace pattern, ( $0, $1 ) =>\n        return @chr_from_cjkvi_ncr_kernel $1\n    send fields\n\n#-----------------------------------------------------------------------------------------------------------\n@$check_glyph_reference = ->\n  return $ ( fields, send ) =>\n    [ glyph_reference, glyph, cjkvi_formulas..., ] = fields\n    unless glyph_reference is glyph\n      key         = glyph_reference + glyph\n      replacement = options[ 'known-ref-mismatches' ][ key ]\n      unless replacement?\n        warn \"unknown glyph reference mismatch: #{rpr glyph_reference}, #{rpr glyph}\"\n      glyph = replacement\n    send [ glyph, cjkvi_formulas, ]\n\n#-----------------------------------------------------------------------------------------------------------\n@$filter_outer_mapped_and_unknown_glyphs = ( glyph_categories ) ->\n  counts =\n    'unknown':                  0\n    'cp/inner/original':        0\n    'cp/inner/mapped':          0\n    'cp/outer/original':        0\n    'cp/outer/mapped':          0\n  unknown_non_cjk_xe = []\n  #.........................................................................................................\n  return $ ( fields, send, end ) =>\n    #.......................................................................................................\n    if fields?\n      [ glyph, cjkvi_formulas, ]  = fields\n      category                    = glyph_categories[ glyph ] ? 'unknown'\n      counts[ category ]         += +1\n      rsg = CHR.as_rsg glyph, input: 'xncr'\n      if category is 'unknown' and not ( rsg in [ 'cdp', 'u-cjk-xe', ] )\n        fncr = CHR.as_fncr glyph, input: 'xncr'\n        unknown_non_cjk_xe.push \"glyph #{fncr} #{glyph}\"\n      send [ glyph, cjkvi_formulas, ] if category is 'cp/inner/original'\n    #.......................................................................................................\n    if end?\n      help \"filtering counts:\"\n      help '\\n' + rpr counts\n      help()\n      help \"of the #{ƒ counts[ 'unknown' ]} unknown codepoints,\"\n      help \"#{ƒ unknown_non_cjk_xe.length} are *not* from Unicode V8 CJK Ext. E:\"\n      help '\\n' + rpr unknown_non_cjk_xe\n      end()\n\n#-----------------------------------------------------------------------------------------------------------\n@$remove_region_annotations = ->\n  return $ ( fields, send ) =>\n    [ glyph, cjkvi_formulas, ]    = fields\n    for formula, idx in cjkvi_formulas\n      cjkvi_formulas[ idx ] = formula.replace /\\[[^\\]]+\\]/g, ''\n    send [ glyph, cjkvi_formulas, ]\n  #.........................................................................................................\n  return R\n\n#-----------------------------------------------------------------------------------------------------------\n@$retrieve_jzr_formulas = ( db ) ->\n  return $async ( fields, done ) =>\n    step ( resume ) =>\n      [ glyph, cjkvi_formulas, ]    = fields\n      prefix                        = [ 'spo', glyph, 'formula', ]\n      query                         = { prefix: prefix, fallback: [ null, null, null, [], ], }\n      phrase                        = yield HOLLERITH.read_one_phrase db, query, resume\n      [ _, _, _, jzr_formulas, ]    = phrase\n      done [ glyph, cjkvi_formulas, jzr_formulas, ]\n  #.........................................................................................................\n  return R\n\n# #-----------------------------------------------------------------------------------------------------------\n# @$retrieve_jzr_formulas = ( db ) ->\n#   R = D.create_throughstream()\n#   R\n#     .pipe $async ( fields, done ) =>\n#       step ( resume ) =>\n#         [ glyph, cjkvi_formulas, ]    = fields\n#         prefix                        = [ 'spo', glyph, 'formula', ]\n#         query                         = { prefix: prefix, fallback: [ null, null, null, [], ], }\n#         phrase                        = yield HOLLERITH.read_one_phrase db, query, resume\n#         [ _, _, _, jzr_formulas, ]    = phrase\n#         done [ glyph, cjkvi_formulas, jzr_formulas, ]\n#     .pipe D.$on_end =>\n#       debug '©VUMHz', 'ok'\n#   #.........................................................................................................\n#   return R\n\n#-----------------------------------------------------------------------------------------------------------\n@$compare_formulas = ->\n  glyph_count   = 0\n  diff_count    = 0\n  missing_count = 0\n  #.........................................................................................................\n  return $ ( fields, send, end ) =>\n    #.......................................................................................................\n    if fields?\n      [ glyph, cjkvi_formulas, jzr_formulas, ] = fields\n      glyph_count += +1\n      if jzr_formulas.length is 0\n        fncr = CHR.as_fncr glyph, input: 'xncr'\n        warn \"no formulas found for glyph #{fncr} #{glyph}\"\n        missing_count += +1\n      else\n        for cjkvi_formula in cjkvi_formulas\n          ### Skip identity formulas like `X = X` which we express as `X = ●` ###\n          continue if cjkvi_formula is glyph\n          if not ( cjkvi_formula in jzr_formulas )\n            fncr = CHR.as_fncr glyph, input: 'xncr'\n            diff_count += +1\n            echo 'difference:', \"#{fncr} #{glyph} #{cjkvi_formula} #{rpr jzr_formulas}\"\n    #.......................................................................................................\n    if end?\n      help \"differences in formulas:\"\n      help \"glyphs:             #{ƒ glyph_count}\"\n      help \"missing formulas:   #{ƒ missing_count}\"\n      help \"different formulas: #{ƒ diff_count}\"\n      end()\n\n#-----------------------------------------------------------------------------------------------------------\n@compare = ->\n  home            = join __dirname, '../../jizura-datasources'\n  cjkvi_route     = join home, 'data/flat-files/shape/github.com´cjkvi´cjkvi-ids/ids.txt'\n  input           = njs_fs.createReadStream cjkvi_route\n  #.........................................................................................................\n  db_route        = join home, 'data/leveldb-v2'\n  db              = HOLLERITH.new_db db_route\n  #.........................................................................................................\n  step ( resume ) =>\n    glyph_categories = yield @read_glyph_categories db, resume\n    input\n      .pipe D.$split()\n      .pipe @$filter_comments_and_empty_lines()\n      # .pipe D.$sample 0.01, seed: 1\n      .pipe D.$parse_csv headers: no, delimiter: '\\t'\n      .pipe @$resolve_cjkvi_kernel()\n      .pipe @$normalize_cjkvi_ncrs()\n      .pipe @$check_glyph_reference()\n      .pipe @$show_progress 1e4\n      .pipe @$filter_outer_mapped_and_unknown_glyphs glyph_categories\n      .pipe @$remove_region_annotations()\n      .pipe @$retrieve_jzr_formulas db\n      .pipe @$compare_formulas()\n      # .pipe D.$show()\n\n  # source_route    = join home, 'data/leveldb'\n  # target_route    = join home, 'data/leveldb-v2'\n  # # target_route    = '/tmp/leveldb-v2'\n  # target_db_size  = 1e6\n  # ds_options      = require join home, 'options'\n  # source_db       = HOLLERITH.new_db source_route\n  # target_db       = HOLLERITH.new_db target_route, size: target_db_size, create: yes\n  # #.........................................................................................................\n  # ### TAINT this setting should come from Jizura DB options ###\n  # # solids          = [ 'guide/kwic/v3/sortcode', ]\n  # solids          = []\n  # #.........................................................................................................\n  # help \"using DB at #{source_db[ '%self' ][ 'location' ]}\"\n  # help \"using DB at #{target_db[ '%self' ][ 'location' ]}\"\n  # #.........................................................................................................\n  # step ( resume ) =>\n  #   yield HOLLERITH.clear target_db, resume\n  #   #.........................................................................................................\n  #   factor_infos  = yield @read_factors source_db, resume\n  #   help \"read #{( Object.keys factor_infos ).length} entries for factor_infos\"\n  #   #.........................................................................................................\n  #   # gte         = 'so|glyph:中'\n  #   # gte         = 'so|glyph:覆'\n  #   gte         = 'so|'\n  #   lte         = @v1_lte_from_gte gte\n  #   input       = source_db[ '%self' ].createKeyStream { gte, lte, }\n  #   batch_size  = 1e4\n  #   output      = HOLLERITH.$write target_db, { batch: batch_size, solids }\n  #   #.........................................................................................................\n  #   help \"copying from  #{source_route}\"\n  #   help \"to            #{target_route}\"\n  #   help \"reading records with prefix #{rpr gte}\"\n  #   help \"writing with batch size #{ƒ batch_size}\"\n  #   #.........................................................................................................\n  #   input\n  #     #.......................................................................................................\n  #     .pipe @v1_$split_so_bkey()\n  #     .pipe @$show_progress 1e4\n  #     .pipe @$keep_small_sample()\n  #     .pipe @$throw_out_pods()\n  #     .pipe @$cast_types ds_options\n  #     .pipe @$collect_lists()\n  #     .pipe @$compact_lists()\n  #     .pipe @$add_version_to_kwic_v1()\n  #     .pipe @$add_kwic_v2()\n  #     .pipe @$add_kwic_v3 factor_infos\n  #     # .pipe D.$show()\n  #     .pipe D.$count ( count ) -> help \"kept #{ƒ count} phrases\"\n  #     .pipe D.$stop_time \"copy Jizura DB\"\n  #     .pipe output\n\n\n############################################################################################################\nunless module.parent?\n  @compare()\n"]}